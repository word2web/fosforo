import { Token } from './token';
import { Errors } from './errors';
import { Node, Decorator, SourceLocation } from './estree';
export declare const enum Context {
    None = 0,
    OptionsNext = 1,
    OptionsRanges = 2,
    OptionsLoc = 4,
    OptionsJSX = 8,
    OptionsLexical = 16,
    OptionsPreserveParens = 32,
    OptionsWebCompat = 64,
    OptionsRaw = 128,
    Strict = 256,
    Module = 512,
    InSwitch = 1024,
    InGlobal = 2048,
    InClass = 4096,
    AllowRegExp = 8192,
    TaggedTemplate = 16384,
    InIteration = 32768,
    SuperProperty = 65536,
    SuperCall = 131072,
    InYieldContext = 262144,
    InAwaitContext = 524288,
    InReturnContext = 1048576,
    InArgumentList = 2097152,
    InConstructor = 4194304,
    InMethodOrFunction = 8388608,
    AllowNewTarget = 16777216,
    DisallowIn = 33554432,
    AllowEscapedKeyword = 67108864,
    OptionsUniqueKeyInPattern = 134217728,
    InStaticBlock = 268435456
}
export declare const enum PropertyKind {
    None = 0,
    Method = 1,
    Computed = 2,
    Shorthand = 4,
    Generator = 8,
    Async = 16,
    Static = 32,
    Constructor = 64,
    ClassField = 128,
    Getter = 256,
    Setter = 512,
    Accessor = 1024,
    Extends = 2048,
    Literal = 4096,
    PrivateField = 8192,
    GetSet = 768
}
export declare const enum BindingKind {
    None = 0,
    ArgumentList = 1,
    Empty = 2,
    Variable = 4,
    Let = 8,
    Const = 16,
    Class = 32,
    FunctionLexical = 64,
    FunctionStatement = 128,
    CatchPattern = 256,
    CatchIdentifier = 512,
    Async = 1024,
    Generator = 1024,
    AsyncFunctionLexical = 1088,
    GeneratorFunctionLexical = 1088,
    AsyncGeneratorFunctionLexical = 1088,
    CatchIdentifierOrPattern = 768,
    LexicalOrFunction = 68,
    LexicalBinding = 248
}
export declare const enum Origin {
    None = 0,
    Statement = 1,
    BlockStatement = 2,
    TopLevel = 4,
    Declaration = 8,
    Arrow = 16,
    ForStatement = 32,
    Export = 64
}
export declare const enum AssignmentKind {
    None = 0,
    Assignable = 1,
    CannotAssign = 2
}
export declare const enum DestructuringKind {
    None = 0,
    HasToDestruct = 8,
    CannotDestruct = 16,
    Assignable = 32,
    SeenProto = 64,
    Await = 128,
    Yield = 256
}
export declare const enum Flags {
    None = 0,
    NewLine = 1,
    HasConstructor = 32,
    Octals = 64,
    NonSimpleParameterList = 128,
    HasStrictReserved = 256,
    StrictEvalArguments = 512,
    DisallowCall = 1024,
    HasOptionalChaining = 2048,
    EightAndNine = 4096
}
export declare const enum HoistedClassFlags {
    None = 0,
    Hoisted = 1,
    Export = 2
}
export declare const enum HoistedFunctionFlags {
    None = 0,
    Hoisted = 1,
    Export = 2
}
export declare const enum ScopeKind {
    None = 0,
    ForStatement = 1,
    Block = 2,
    CatchStatement = 4,
    SwitchStatement = 8,
    ArgList = 16,
    TryStatement = 32,
    CatchBlock = 64,
    FunctionBody = 128,
    FunctionRoot = 256,
    FunctionParams = 512,
    ArrowParams = 1024,
    CatchIdentifier = 2048
}
export type OnComment = (type: string, value: string, start: number, end: number, loc: SourceLocation) => any;
export type OnInsertedSemicolon = (pos: number) => any;
export type OnToken = (token: string, start: number, end: number, loc: SourceLocation) => any;
export interface ScopeState {
    parent: ScopeState | undefined;
    type: ScopeKind;
    scopeError?: ScopeError | null;
}
export interface PrivateScopeState {
    parent: PrivateScopeState | undefined;
    refs: {
        [name: string]: {
            index: number;
            line: number;
            column: number;
        }[];
    };
}
export interface ScopeError {
    type: Errors;
    params: string[];
    index: number;
    line: number;
    column: number;
    tokenIndex: number;
    tokenLine: number;
    tokenColumn: number;
}
export interface ParserState {
    source: string;
    end: number;
    flags: Flags;
    index: number;
    line: number;
    column: number;
    tokenIndex: number;
    tokenColumn: number;
    tokenLine: number;
    startIndex: number;
    startColumn: number;
    startLine: number;
    getToken(): Token;
    setToken(token: Token, replaceLast?: boolean): Token;
    onComment: OnComment | void;
    onInsertedSemicolon: OnInsertedSemicolon | void;
    onToken: OnToken | void;
    tokenValue: any;
    tokenRaw: string;
    tokenRegExp: void | {
        pattern: string;
        flags: string;
    };
    sourceFile: string | void;
    assignable: AssignmentKind | DestructuringKind;
    destructible: AssignmentKind | DestructuringKind;
    currentChar: number;
    exportedNames: any;
    exportedBindings: any;
    leadingDecorators: Decorator[];
}
export declare function matchOrInsertSemicolon(parser: ParserState, context: Context): void;
export declare function isValidStrictMode(parser: ParserState, index: number, tokenIndex: number, tokenValue: string): 0 | 1;
export declare function optionalBit(parser: ParserState, context: Context, t: Token): 0 | 1;
export declare function consumeOpt(parser: ParserState, context: Context, t: Token): boolean;
export declare function consume(parser: ParserState, context: Context, t: Token): void;
export declare function reinterpretToPattern(state: ParserState, node: any): void;
export declare function validateBindingIdentifier(parser: ParserState, context: Context, kind: BindingKind, t: Token, skipEvalArgCheck: 0 | 1): void;
export declare function validateFunctionName(parser: ParserState, context: Context, t: Token): void;
export declare function isStrictReservedWord(parser: ParserState, context: Context, t: Token): boolean;
export declare function isPropertyWithPrivateFieldKey(expr: any): boolean;
export declare function isValidLabel(parser: ParserState, labels: any, name: string, isIterationStatement: 0 | 1): 0 | 1;
export declare function validateAndDeclareLabel(parser: ParserState, labels: any, name: string): void;
export declare function finishNode<T extends Node>(parser: ParserState, context: Context, start: number, line: number, column: number, node: T): T;
export declare function createArrowHeadParsingScope(parser: ParserState, context: Context, value: string): ScopeState;
export declare function recordScopeError(parser: ParserState, type: Errors, ...params: string[]): ScopeError;
export declare function createScope(): ScopeState;
export declare function addChildScope(parent: ScopeState | undefined, type: ScopeKind): ScopeState;
export declare function addChildPrivateScope(parent: PrivateScopeState | undefined): PrivateScopeState;
export declare function addVarOrBlock(parser: ParserState, context: Context, scope: ScopeState, name: string, kind: BindingKind, origin: Origin): void;
export declare function addBlockName(parser: ParserState, context: Context, scope: any, name: string, kind: BindingKind, origin: Origin): void;
export declare function addVarName(parser: ParserState, context: Context, scope: ScopeState, name: string, kind: BindingKind): void;
export declare function addPrivateIdentifier(parser: ParserState, scope: PrivateScopeState, name: string, kind: PropertyKind): void;
export declare function addPrivateIdentifierRef(parser: ParserState, scope: PrivateScopeState, name: string): void;
export declare function validatePrivateIdentifierRefs(scope: PrivateScopeState): void;
export declare function declareUnboundVariable(parser: ParserState, name: string): void;
export declare function addBindingToExports(parser: ParserState, name: string): void;
export declare function pushComment(context: Context, array: any[]): OnComment;
export declare function pushToken(context: Context, array: any[]): OnToken;
export declare function isValidIdentifier(context: Context, t: Token): boolean;
export declare function classifyIdentifier(parser: ParserState, context: Context, t: Token): any;
//# sourceMappingURL=common.d.ts.map